#!/usr/bin/python
#
#
desc="Calculate sum/avg of each columns for table-like text file data like *.csv."

import argparse
import re
import sys

parser = argparse.ArgumentParser(description=desc)
parser.add_argument('filename', metavar='FILE', type=str, nargs='?')
parser.add_argument('-F', metavar='IFS', default=None,
            help='Input field separator, like awk')
parser.add_argument('--strict', dest='ignore_error', action='store_true', default=False,
            help='Do not ignore malformed field in the input.')
parser.add_argument('--ignore', action='store_true', default=False,
            help='Do not ignore malformed field in the input.')



def isnum(string):
    return string.replace(".", "", 1).isdigit()


class BadLineError(Exception):
    pass

class BadCellError(Exception):
    pass

class EmptyCellError(Exception):
    pass



def guess_delimiter(line):
    if ',' in line:
        return ','
    elif '\t' in line:
        return '\t'
    else:
        return ' +'


class Tabulation(object):
    def __init__(self, firstline=None, delimiter=None,
                ignore=False, ignore_error=False, ignore_empty=True):
        self.accum        = None
        self.delim        = None
        self.ignore       = ignore
        self.ignore_error = ignore_error
        self.ignore_empty = ignore_empty
        self.initialized  = False
        if firstline is not None:
            self._initialize(firstline, delimiter)
        else:
            self.delim = delimiter

    def _initialize(self, firstline, delimiter=None):
        if isinstance(firstline, list):
            if self.delim is None:
                self.delim = delimiter
            cols = firstline
        else:
            cols = self.split(firstline)

        self.initialized = True

        if all([ isnum(x) for x in cols[1:] ]):
            self.header = None
            self.feed(cols)
        else:
            self.header = cols

    def split(self, line, delimiter=None):
        """
        >>> t = Tabulation(ignore_error=True)
        >>> t.split("foo,bar,baz")
        ['foo', 'bar', 'baz']
        >>> t.delim = None; t.split("foo bar   baz  ")
        ['foo', 'bar', 'baz']
        >>> t.delim = None; t.split("foo\tbar\tbaz")
        ['foo', 'bar', 'baz']
        >>> t.delim = ':'; t.split("foo:bar:baz")
        ['foo', 'bar', 'baz']
        """
        if delimiter is not None:
            self.delim = delimiter
        elif self.delim is None:
            self.delim = guess_delimiter(line)
        line = line.rstrip()
        return re.split(self.delim, line)

    def _combine(self, a, cell):
        """
        >>> t = Tabulation(ignore_error=True)
        >>> t._combine([1, 2], "3")
        [1, 2, 3]
        >>> t._combine([1, 2], "3.0")
        [1, 2, 3.0]
        >>> t._combine(None, "123")
        [123]
        >>> t._combine([1, 2], "broken")
        [1, 2]
        >>> t._combine(None, "broken")
        []
        """
        if cell is None:
            return a
        else:
            cell = cell.strip()
            if isnum(cell):
                if '.' in cell:
                    num = float(cell)
                else:
                    num = int(cell)
            elif cell == '':
                if self.ignore or self.ignore_empty:
                    num = None
                else:
                    raise EmptyCellError()
            else:
                if self.ignore or self.ignore_error:
                    num = None
                else:
                    raise BadCellError(cell)

            if num is None:
                if a is None:
                    return []
                else:
                    return a
            elif a is None:
                return [num]
            else:
                return a + [num]

    def feed(self, cols):
        if not self.initialized:
            self._initialize(cols)
        else:
            if self.accum is None:
                if isnum(cols[0]):
                    self.accum = [] # list of Column
                else:
                    self.accum = {} # dict of list of Column

            if isinstance(self.accum, dict):
                key = cols[0]
                cols = cols[1:]
                if key in self.accum:
                    self.accum[key] = map(self._combine, self.accum[key], cols)
                else:
                    self.accum[key] = map(self._combine, [], cols)
            elif isinstance(self.accum, list):
                self.accum = map(self._combine, self.accum, cols)
            else:
                raise Exception("You found a bug")


    def feedline(self, line, delimiter=None):
        """
        >>> t = Tabulation("1,2,3")
        >>> t.feedline("4,5,6")
        >>> t.accum
        [[1, 4], [2, 5], [3, 6]]
        >>> t = Tabulation("attr col1 col2")
        >>> t.feedline("foo 1 2")
        >>> t.feedline("bar 12 34")
        >>> t.feedline("foo 3 4")
        >>> t.feedline("bar 56 78")
        >>> t.header
        ['attr', 'col1', 'col2']
        >>> t.accum
        {'foo': [[1, 3], [2, 4]], 'bar': [[12, 56], [34, 78]]}
        """
        cols = self.split(line, delimiter)
        self.feed(cols)

    def calc(self, f):
        if isinstance(self.accum, dict):
            a = {}
            for i in self.accum:
                a[i] = map(f, self.accum[i])
            return a
        elif isinstance(self.accum, list):
            return map(f, self.accum)
        else:
            return None

    def sum(self):
        """
        >>> t = Tabulation("1,2,3"); t.feedline("4,5,6"); t.feedline("7,8,9")
        >>> t.sum()
        [12, 15, 18]
        >>> t.avg()
        [4.0, 5.0, 6.0]
        >>> t = Tabulation("foo,1,2,3")
        >>> t.feedline("bar,4,5,6");  t.feedline("foo,7,8,9")
        >>> t.feedline("baz,7,6,5");  t.feedline("bar,3,2,1")
        >>> t.sum() == {'foo': [8, 10, 12], 'bar': [7, 7, 7], 'baz': [7, 6, 5]}
        True
        >>> t.avg() == {'foo': [4.0, 5.0, 6.0], 'bar': [3.5, 3.5, 3.5], 'baz': [7.0, 6.0, 5.0]}
        True
        """
        return self.calc(sum)

    def avg(self):
        return self.calc(lambda x: float(sum(x))/len(x))

    def output(self, outfd, calc='sum', delimiter=None, align=None):
        """ FIXME: align not implemented yet.
        """
        if delimiter:
            ofs = delimiter
        elif len(self.delim) == 1:
            ofs = self.delim
        else:
            ofs = ' '
            if align is None:
                align=True

        if calc == 'sum':
            s = self.sum()
        elif calc == 'avg':
            s = self.avg()

        if self.header:
            outfd.write(ofs.join(self.header) + '\n')

        if isinstance(s, dict):
            for key in self.accum:
                outfd.write(ofs.join([key] + map(str, s[key])) + '\n')
        else:
            outfd.write(ofs.join(map(str,s)) + '\n')



def calc_lines(i, delimiter=None):
    line = i.readline()
    t = Tabulation(delimiter=delimiter)
    while line:
        t.feedline(line)
        line = i.readline()
    return t



def main(args):
    if (args and args[0] == '--doctest'):
        import doctest
        doctest.testmod()
    else:
        args = parser.parse_args(args)
        if args.filename:
            f = open(args.filename)
            t = calc_lines(f, args.F)
        else:
            t = calc_lines(sys.stdin, args.F)

        t.output(sys.stdout, 'sum')



if __name__ == '__main__':
    main(sys.argv[1:])

