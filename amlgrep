#!/bin/bash
#
#   amlgrep - Awk Multi-line Log grep
#
# A grep for multiline log records - (not so) simple wrapper for
# awk with setting IFS/RS/ORS automatically
#
# NOTE: You should use '\n' instead of ^ or $ to
# indicate beginnings and endings of lines (fields)
# (TODO: automatically replacing '^' and '$' with '\n' would be nice?)
#
print_help () {
cat <<EOF
Usage: $0 [--or|--and] [--] PATTERNS... [--] [FILES...]
  grep like tool to search multi-line log entries separated by '-----------'.
  In reality, just an awk wrapper with RS='\\n-----------\\n' and IFS='\\n'
  If an argument is an existing file or '-' (means standard input) or '--',
  the argument and everything after that will be treated as filenames to read
  from. (If you just want to search literal '-' or '--', use '[-]' or '-{2}')
  If file name is *.gz, *.bz2 or *.xz, uncompress it on-the-fly before
  reading from it.
OPTIONS
  -h, --help  Print this help.
  -o, --or    Print entries match with any of PATTERNS. This is the default.
  -a, --and   Print entries match with all of PATTERNS.
  -c, --count Print number of matches.
  --color
  -m, --mono  Highlight or do not matches. Default is to highlight matches if
              standard out is a terminal.
  -v, --invert-match
        Select non-matching lines.
  -r, --rs, --record-separator
        Set input record separater. Default is "$opt_RS"
  --ors, --output-record-separator
        Set output record separater. Default is "$opt_ORS"
EOF
}

set -eu


#################################################################
##
## Detect awk type
##
## the original awk and nawk doesn't allow regex or '\n' in RS
## So need to auto-detect type of awk available and adjust RS
##

if type gawk > /dev/null 2>&1
then
    awk='gawk'
    awk_type='gawk'
elif type mawk > /dev/null 2>&1
then
    awk='mawk'
    awk_type='mawk'
elif type awk > /dev/null 2>&1
then
    if awk --version 2>/dev/null | grep -q 'GNU'
    then
        awk='awk'
        awk_type='gawk'
    else
        # Maybe you comment out 'exit 1',
        # uncomment the lower two lines and case statement below
        # to use nawk or original awk -- but not sure if it's
        # fully compatible.
        echo "$0: ERROR: mawk or gawk is required"
        exit 1
        #awk='awk'
        #awk_type='awk'
    fi
else
    echo "$0: ERROR: awk is not found (missing \$PATH ?)"
    exit 1
fi

#case $awk_type in
#    gawk) opt_RS='\n----------------*\n';;
#    *)    opt_RS='-----------------';;
#esac


#################################################################
##
## cmdline option parser
##
opt_conjunction='OR'
opt_invert='no'
opt_count='no'
opt_color='auto'
opt_RS='\n----------------*\n'
opt_ORS='\n----------------\n'
while [ $# -ge 1 ]
do
case $1 in
    -[^-][^-]*)
        firstarg="$1"; shift
        set -- ${firstarg:0:2} -${firstarg:2} "$@"; continue;;
    --*=*)
        firstarg="$1"; shift;
        set -- ${firstarg%%=*} ${firstarg#*=} "$@"; continue;;
    #------------------------------------------
    -o|--or)  opt_conjunction='OR';;
    -a|--and) opt_conjunction='AND';;
    -v|--invert|--invert-match) opt_invert='yes';;
    -r|--rs|--record-separator) opt_RS="$2"; shift;;
    --ors|--output-record-separator) opt_ORS="$2"; shift;;
    -c|--count) opt_count='yes';;
    --color) opt_color='always';;
    --mono) opt_color='never';;
    #------------------------------------------
    -h|--help) print_help; exit 0;;
    --) shift; break;;
    -*) echo "ERROR: Unknown option: $1">&2; exit 1;;
    *) break ;;
esac
shift
done

[ "$opt_invert" = yes ] && opt_conjunction="N${opt_conjunction}"
IFS='\n'
RS="$opt_RS"
ORS="$opt_ORS"
awkargs=(-F "$IFS" -v RS="$RS" -v ORS="$ORS")

if [ $# -lt 1 ]; then
    print_help
    exit 1
fi

if [ "$opt_color" = 'always' -o "$opt_color" = 'auto' -a -t 1 ]
then
    highlight="yes"
else
    highlight="no"
fi


#################################################################
##
## Build an AWK script
##
awkpat="$1"  # OR logic
awkcond="\$0 ~ /$1/" # AND logic
shift
while [ $# -ge 1 ]
do
    pattern="$1"
    [ -e "$pattern" ] && break
    case "$pattern" in
        -)  break;; # stdin
        --) shift; break;;
    esac
    awkpat="${awkpat}|$pattern"
    awkcond="${awkcond} && \$0 ~ /$pattern/"
shift; done


if [ "$opt_count" = 'yes' ]
then
    awkprint=''
elif [ "$highlight" = 'yes' ]
then
    awkprint="gsub(/$awkpat/, \"$(tput rev)&$(tput sgr0)\");print"
else
    awkprint='print'
fi


case $opt_conjunction in
    OR)   awkstatement="       /$awkpat/   {i++;$awkprint}";;
    NOR)  awkstatement="\$0 !~ /$awkpat/   {i++;$awkprint}";;
    AND)  awkstatement="{if   (${awkcond}) {i++;$awkprint}}";;
    NAND) awkstatement="{if (!(${awkcond})){i++;$awkprint}}";;
esac

awkexit='if (i>0){exit 0}else{exit 1}'
if [ "$opt_count" = 'yes' ]
then
    awkstatement="$awkstatement END{printf \"%d\n\", i; $awkexit}"
else
    awkstatement="$awkstatement END{$awkexit}"
fi

#################################################################
##
## Run
##

# read from stdin ("-") if no file name is given
[ $# -eq 0 ] && set -- "-"

for file in "$@"
do
    case "$file" in
        *.gz)  gunzip -c "$file";;
        *.bz2) bzcat "$file";;
        *.xz)  xzcat "$file";;
        *)     cat "$file";;
    esac | $awk "${awkargs[@]}" "$awkstatement"
done
