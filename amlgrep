#!/bin/bash
#
#   amlgrep - Awk Multi-line Log grep
#
# A grep for multiline log records - (not so) simple wrapper for
# awk with setting IFS/RS/ORS automatically
#
print_help () {
cat <<EOF
Usage: $0 [OPTIONS] [--] PATTERNS... [--] [FILES...]
  grep like tool to search multi-line log separated by '$opt_RS'.
  (--rs option to change this) In reality, just an awk wrapper with
  RS='$opt_RS', ORS='$opt_ORS' and IFS='\\n')
  If an argument is a name of existing file or '-', that argument and
  everything after that will be treated as filenames to read from.
  If file name ends with .gz, .bz2 or .xz, uncompress it on-the-fly before
  reading from it.
OPTIONS
  -h, --help            Print this help.
  -v, --invert-match    Select non-matching lines (same as grep -v).
  -i, --ignore-case     Case-insensitive match (same as grep -i).
  -c, --count           Print number of matches.
  --color, -m, --mono   (Do not) Highlight matches.
        (Default is to highlight matches if standard out is a terminal.)
  -a, --and   Print entries match with all, instead of any, of PATTERNS.
  -r, --rs    Set input record separater. Default is "$opt_RS"
  --ors       Set output record separater. Default is "$opt_ORS"
  --dump      Dump the awk commands that would be executed.
BUGS
  --ignore-case option only works when gawk is available on your system,
  and it also affects how regex for --rs option is interpreted.
EOF
}

set -eu

DIE () { echo "$0: ERROR: $*" >&2; exit 1; }

#################################################################
##
## Detect awk type
##
## the original awk and nawk doesn't allow regex or '\n' in RS
## So need to auto-detect type of awk available and adjust RS
##

if type gawk > /dev/null 2>&1
then
    awk='gawk'
    awk_type='gawk'
elif type mawk > /dev/null 2>&1
then
    awk='mawk'
    awk_type='mawk'
elif type awk > /dev/null 2>&1
then
    if awk --version 2>/dev/null | grep -q 'GNU'
    then
        awk='awk'
        awk_type='gawk'
    else
        # Maybe you comment out 'exit 1',
        # uncomment the lower two lines and case statement below
        # to use nawk or original awk -- but not sure if it's
        # fully compatible.
        echo "$0: ERROR: mawk or gawk is required"
        exit 1
        #awk='awk'
        #awk_type='awk'
    fi
else
    DIE "ERROR: awk is not found (missing \$PATH ?)"
fi

#case $awk_type in
#    gawk) opt_RS='\n----------------*\n';;
#    *)    opt_RS='-----------------';;
#esac


#################################################################
##
## cmdline option parser
##
opt_conjunction='OR'
opt_invert='no'
opt_count='no'
opt_color='auto'
opt_ignorecase='no'
opt_RS='\n--------*\n'
opt_ORS='\n--------\n'
opt_dump='no'
while [ $# -ge 1 ]
do
case $1 in
    -[^-][^-]*)
        firstarg="$1"; shift
        set -- ${firstarg:0:2} -${firstarg:2} "$@"; continue;;
    --*=*)
        firstarg="$1"; shift;
        set -- ${firstarg%%=*} ${firstarg#*=} "$@"; continue;;
    #------------------------------------------
    -o|--or)  opt_conjunction='OR';;
    -a|--and) opt_conjunction='AND';;
    -v|--invert|--invert-match) opt_invert='yes';;
    -c|--count) opt_count='yes';;
    -i|--ignore-case) opt_ignorecase='yes';;
    -r|--rs|--record-separator) opt_RS="$2"; shift;;
    --ors|--output-record-separator) opt_ORS="$2"; shift;;
    --color) opt_color='always';;
    --mono) opt_color='never';;
    --dump) opt_dump='yes';;
    #------------------------------------------
    -h|--help) print_help; exit 0;;
    --) shift; break;;
    -*) echo "ERROR: Unknown option: $1">&2; exit 1;;
    *) break ;;
esac
shift
done

[ "$opt_invert" = yes ] && opt_conjunction="N${opt_conjunction}"
IFS='\n'
RS="$opt_RS"
ORS="$opt_ORS"
awkargs=(-F "$IFS" -v RS="$RS" -v ORS="$ORS")

if [ $# -lt 1 ]; then
    print_help
    exit 1
fi

if [ "$opt_ignorecase" = 'yes' ]
then
    if [ "$awk_type" = 'gawk' ]
    then
        awkargs+=('-v' 'IGNORECASE=1')
    else
        DIE "-i (--ignore-case) option needs gawk. " \
            "Your awk on this system is: '$awk'"
    fi
fi

if [ "$opt_color" = 'always' -o "$opt_color" = 'auto' -a -t 1 ]
then
    highlight="yes"
else
    highlight="no"
fi


#################################################################
##
## Build an AWK script
##

sanitize_pattern () {
    local pattern="$1"
    local slash=''
    case $pattern in
        '^'*) pattern="${pattern/^/\\n}"       ;;
    esac
    case $pattern in
        *'\$') : it is escaped - ignore        ;;
        *[^\\]'$') pattern="${pattern/\$/\\n}" ;;
    esac
    echo "${pattern//\//\/}"
}

first_pattern="$(sanitize_pattern "$1")"
awkpat="$first_pattern"  # OR logic
awkcond="\$0 ~ /$first_pattern/" # AND logic
shift
while [ $# -ge 1 ]
do
    pattern="$(sanitize_pattern "$1")"
    [ -e "$pattern" ] && break
    case "$pattern" in
        -)  break;; # stdin
        --) shift; break;;
    esac
    awkpat="${awkpat}|$pattern"
    awkcond="${awkcond} && \$0 ~ /$pattern/"
shift; done


if [ "$opt_count" = 'yes' ]
then
    awkprint=''
elif [ "$highlight" = 'yes' ]
then
    awkprint="gsub(/$awkpat/, \"$(tput rev)&$(tput sgr0)\");print"
else
    awkprint='print'
fi


case $opt_conjunction in
    OR)   awkstatement="       /$awkpat/   {i++;$awkprint}";;
    NOR)  awkstatement="\$0 !~ /$awkpat/   {i++;$awkprint}";;
    AND)  awkstatement="{if   (${awkcond}) {i++;$awkprint}}";;
    NAND) awkstatement="{if (!(${awkcond})){i++;$awkprint}}";;
esac

awkexit='if (i>0){exit 0}else{exit 1}'
if [ "$opt_count" = 'yes' ]
then
    awkstatement="$awkstatement END{printf \"%d\n\", i; $awkexit}"
else
    awkstatement="$awkstatement END{$awkexit}"
fi

#################################################################
##
## Run
##

# read from stdin ("-") if no file name is given
[ $# -eq 0 ] && set -- "-"

errors=0
if [ "$opt_dump" = 'yes' ]
then
    for arg in "$awk" "${awkargs[@]}" "$awkstatement"
    do
        echo "$arg"
    done | xargs -d'\n' -I{} -n1 echo -n "'{}' "
    echo
else
    for file in "$@"
    do
        if [ $# -ge 2 -a $opt_count ]
        then
            echo -n "$file: "
        fi
        case "$file" in
            *.gz)  gunzip -c "$file";;
            *.bz2) bzcat "$file";;
            *.xz)  xzcat "$file";;
            *)     cat "$file";;
        esac | $awk "${awkargs[@]}" "$awkstatement" || let ++errors
    done
    if (( errors > 0 ))
    then
        exit 1
    else
        exit 0
    fi
fi
