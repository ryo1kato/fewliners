#!/bin/bash

set -ue

print_help () {
cat <<EOF
Usage: $0 [OPTIONS] [FILE]
  like tee(1), but output number of lines while saving to file.
  This is intended to be used, like pv[1] command, but for text file
  (like compiler output, log files or any line oriented data) to check
  realtime data flows in pipes.

  If stdout is not a terminal, this command behaves just like tee(1).
OPTIONS
    -h,--help             Show this help
    -a,--append           Append to file
    -o,--overwrite        Overwrite existing file
    -e,--error            Count lines with /error/i
    -w,--warn             Count lines with /warn/i
    -k,--keyword=REGEX    Count lines with /keyword/i
    -c,--case-sensitive   Make the pattern case-sensitive
                          (use all upper cases for -e and -w)
    -t,--time             Show time elapsed.
BUGS
  This command is too slow to process output of grep from filesystem.
SEE ALSO
  [1] pv http://www.ivarch.com/programs/pv.shtml
EOF
}

###############################################################################

DIE () { echo "ERROR: $@" >&2; exit 1; }

pretty_sec () {
    local seconds=$1
    local min sec
    ((min = seconds / 60)) || true
    ((sec = seconds % 60)) || true
    echo "${min}m ${sec}s"
}


shopt -s nocasematch
tee_opt='--'
tee_file='no'
opt_error='no'
opt_warn='no'
opt_overwrite='no'
opt_keyword=''
opt_showtime='no'
while [ $# -ge 1 ]
do
case $1 in
    -[^-][^-]*)
        # expand '-abcd' to '-a -bcd' (and eventually '-a -b -c -d')
        firstarg="$1"; shift
        set -- ${firstarg:0:2} -${firstarg:2} "$@"; continue;;
    --*=*)
        firstarg="$1"; shift;
        set -- ${firstarg%%=*} ${firstarg#*=} "$@"; continue;;
    -a|--apend)     opt_overwrite='no'; tee_opt='-a';;
    -h|--help)      print_help; exit 0;;
    -o|--overwrite) opt_overwrite='yes'; tee_opt='--';;
    -e|--error)     opt_error='yes';;
    -w|--warn)      opt_warn='yes';;
    -k|--keyword)   opt_keyword="$2"; shift;;
    -t|--time)      opt_showtime='yes';;
    -c|--case-sensitive) shopt -u nocasematch;;
    --) break;;
    -*) DIE "Unknown option '$1'";;
    *) break;;
esac
shift
done


###############################################################################

inc () {
    let "${1}++" || true
}

fancytee () {
    local start_time=$SECONDS
    local nr_line=0
    local nr_error=0
    local nr_warn=0
    local nr_keyword=0
    local lastupdate=0
    local status=''

    while read line
    do
        inc nr_line
        [[ "$opt_error" = yes && $line =~ ERROR ]] && inc nr_error
        [[ "$opt_warn" = yes  && $line =~ WARN ]] && inc nr_warn
        [[ -n "$opt_keyword"  && $line =~ $opt_keyword ]] && inc nr_keyword

        if [ $SECONDS -ne $lastupdate ]; then
            # clear the previous status line with same length of whitespaces
            printf "\r${status//?/ }\r"

            status="$nr_line lines"
            [ "$opt_error" = yes ] &&
                status="$status, $nr_error errors"
            [ "$opt_warn" = yes ] &&
                status="$status, $nr_warn warns"
            [ -n "$opt_keyword" ] &&
                status="$status, $nr_keyword matches for /$opt_keyword/"
            [ "$opt_showtime" = yes ] &&
                status="$status, in $(pretty_sec $((SECONDS - start_time)) )"
            echo -n "$status"
            lastupdate=$SECONDS
        fi
    done >&2
    end_time=$SECONDS
    echo >&2
}


if [ $# -eq 1 ]; then
    file="$1"
    if [[ $tee_opt != -a && $opt_overwrite != yes && -e $file ]]
    then
        DIE "$file exists. (-o to overwrite, -a to append)"
    fi
else
    file='/dev/null'
fi


if [ -t 1 ]
then
    tee "$tee_opt" "$file" | fancytee
else
    tee "$tee_opt" "$file"
fi
