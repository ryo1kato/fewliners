#!/bin/bash
#
# para - poor man's parallelizer
#
set -ue
trap 'echo "$0: Unexpected error at line $LINENO" >&2; exit 1;' ERR

b () { tput bold; echo -n "$*"; tput sgr0; } # bold
u () { tput smul; echo -n "$*"; tput rmul; } # underline

print_help () {
cat <<EOF
Usage: ${0##*/} [$(u OPTIONS)...] $(u COMMAND) [$(u ARGS)] < $(u PARAM_FILE)
A simpler GNU parallel like parallelizer implemented with Bash.
For each line of $(u PARAM_FILE), run $(u COMMAND) [$(u ARGS)...] with $(b {})
replaced with the content of the line.
$(b OPTIONS)
-j,--jobs=$(u NUM)     Run maximum $(u NUM) jobs in parallel (default=$opt_jobs).
-h,--help         Print this help.
-b,--buffered     Buffer all outputs from $(u COMMAND) before print to terminal.
                  Prevents inter-mixed output, but needs as much RAM
-o,--output=$(u FILE)  Redirect command output to $(u FILE)
                  If placeholder(s) $(b {}) is contained in $(u FILE),
                  output will be separated per commands, with $(b {}) substitued.
                  Otherwise all outputs will be sent to one file $(u FILE).
-e,--error        Immediately exit when observing any error.
                  Because commands are ran in parallel, this option doesn't
                  necessarily stop commands following the one failed from being
                  executed.
-v,--verbose      Print command strings being executed to stderr.
                  -vv will print start and end of command, with run time.
$(b RETURN CODE)
  Exits with code 0 if all of the commands ran exitted successfully.
  Otherwise print number of commands exitted with non-zero code and
  exits with code 1. For bash older than ver4.3, errors are ignored,
  and as such, '--error' option doesn't work.
$(b BUGS)
  Unlike GNU parallel, this command doesn't support reading from multiple
  files or placeholder variants like {.}, {/}, {1}, {2}, etc.
EOF
}


###############################################################################
WARN () { echo "WARN: ${0##*/}: $@" >&2; }
ERROR () { echo "ERROR: ${0##*/}: $@" >&2; }
DIE () { ERROR "$*"; exit 1; }

enabled () {
    [ "$1" == 'yes' ]
}


bash_is_old='no';
case $BASH_VERSION in
[123].*|4.[012].*)
    #if [ $BASH = /bin/bash -a -x /usr/local/bin/bash ]
    #then
    #    # MacOSX users might have newer version of bash in /usr/local
    #    exec /usr/local/bin/bash "$0" "$@"
    #fi
    WARN "Your bash is too old ($BASH_VERSION). Errors will be ignored."
    bash_is_old='yes';
    ;;
esac


opt_verbose=0
opt_jobs=8
opt_print='no'
opt_error='no'
opt_buffer='no'
opt_output=''


while [ $# -ge 1 ]
do
case $1 in
    -j[1-9]|-j[1-9][0-9]|-j[1-9][0-9][0-9])
        opt_jobs=${1#-j};;
    -[^-][^-]*)
        # expand '-abcd' to '-a -bcd' (and eventually '-a -b -c -d')
        firstarg="$1"; shift
        set -- "${firstarg:0:2}" "-${firstarg:2}" "$@"; continue;;
    --*=*)
        firstarg="$1"; shift;
        set -- "${firstarg%%=*}" "${firstarg#*=}" "$@"; continue;;
    -j|--jobs)       opt_jobs="$2"; shift;;
    -b|--buffered)     opt_buffer='yes';;
    -h|--help)       print_help; exit 0;;
    -o|--output)     opt_output="$2"; shift;;
    -e|--error)      opt_error='yes';;
    -v|--verbose)    let opt_verbose++ || true;;
    --) shift; break;;
    -*) DIE "Unknown option '$1'";;
    *) break;;
esac
shift
done


output_per_command='no'
case "$opt_output" in
    '')     : ;;
    *'{}'*) output_per_command='yes'
            opt_buffer='no'
            ;;
    *)      touch $opt_output;;
esac


errors=0
max_jobs=$opt_jobs
(( max_jobs > 1 )) || max_jobs=1
cmd=("$@")
nth=1
while IFS='' read -r line
do
    if [ $errors -gt 0 -a $opt_error = 'yes' ]
    then
        DIE "Exitting with an error, as --error option is given."
    fi

    while true
    do
        jobs=($(jobs -p))
        nr_jobs=${#jobs[@]}
        if (( max_jobs > nr_jobs ))
        then
            break
        else
            if enabled "$bash_is_old"
            then
                sleep 0.1
            else
                wait -n || (( ++errors ))
                break
            fi
        fi
    done

    if (( opt_verbose > 0 )) ; then
        echo "[$nth] ${cmd[@]//\{\}/$line}" >&2
    fi
    (
        set +e
        time_start=$SECONDS

        if enabled $opt_buffer
        then
            # Note that if $output_per_command is 'yes', $opt_buffer is 'no'
            output=$("${cmd[@]//\{\}/$line}"); ret=$?
            if [ -n "$opt_output" ]
            then
                echo "$output" >> "$opt_output"
            else
                echo "$output"
            fi
        elif enabled $output_per_command
        then
            "${cmd[@]//\{\}/$line}" > "${opt_output//\{\}/$line}"; ret=$?
        elif [ -n "$opt_output" ]
        then
            "${cmd[@]//\{\}/$line}" >> "${opt_output}"; ret=$?
        else
            "${cmd[@]//\{\}/$line}"; ret=$?
        fi

        time_end=$SECONDS
        if (( opt_verbose > 1 )) ; then
            echo "[$nth] ${cmd[@]//\{\}/$line} FINISHED in $((time_end - time_start)) secs" >&2
        fi
        exit $ret
    ) &

    let nth++
done


# This waits for all remaining jobs and return zero.
if enabled "$bash_is_old"
then
    wait
else
    while [ "$(jobs -p)" != '' ]
    do
        if ! wait -n
        then
            if enabled $opt_error
            then
                DIE "Exitting with an error, as --error option is given."
            else
                let ++errors
            fi
        fi
    done
fi

if (( errors > 0 ))
then
    WARN "Had $errors errors."
    exit 1
else
    exit 0
fi
