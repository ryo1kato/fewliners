#!/bin/bash
#
# Pretty print args of a process of given PID (read from /proc/<PID>/cmdline),
# or print all arguemnts one arg per line.
# Doesn't work as expected if there's an arg with newline('\n') in it.
#
set -ue
trap 'echo "$0: Unexpected error at line $LINENO" >&2; exit 1;' ERR

DIE () {
    echo "$0: ERROR: $*"
    exit 1
}

newline=$'\n'

print_help () {
cat <<EOF
Usage: $0 [OPTIONS] [--] {PID|ARGS[...]}
  Pretty-print long array of arguments to see what's a command is running.
  If there's only one argument and it's a number(PID), this command prints
  args of the process of that PID (from /proc/<PID>/cmdline), one per line.
  If there's more than two arguments, or the first argument is not a
  number, it prints all arguments one per line.
  By default long line will be shoten to make it fit in one line.
  You can suppress that behavior by '-f' option
OPTIONS
  -p, --pid    Force interpretation of
  -c, --color  Print args with background color to see trailing whitespaces.
               Default is ENABLED if stdout is a terminal.
  -m, --mono   Don't use color even for terminal output.
  -e, --escape Convert newlines to literal '\\n'.
               With --color option, it also change color.
  -n, --number Print line number
  -h, --help   Print this help
  -f, --full   Don't omit long (by default, cut by \$COLUMNS chars)
EOF
}

recursive_opts=()
opt_full=no
opt_lineno=no
opt_pid=no
opt_color=no
opt_escape=no

default_cols=80
mid_omit_minimum=60
tail_keep=10

        BLACK=$'\e[0;30m';         BG_BLACK=$'\e[0;40m'
         BLUE=$'\e[0;34m';          BG_BLUE=$'\e[0;44m'
        GREEN=$'\e[0;32m';         BG_GREEN=$'\e[0;42m'
         CYAN=$'\e[0;36m';          BG_CYAN=$'\e[0;46m'
          RED=$'\e[0;31m';           BG_RED=$'\e[0;41m'
       PURPLE=$'\e[0;35m';        BG_PURPLE=$'\e[0;45m'
        BROWN=$'\e[0;33m';         BG_BROWN=$'\e[0;43m'
   LIGHT_GRAY=$'\e[0;37m';    BG_LIGHT_GRAY=$'\e[0;47m'
    DARK_GRAY=$'\e[1;30m';     BG_DARK_GRAY=$'\e[1;40m'
   LIGHT_BLUE=$'\e[1;34m';    BG_LIGHT_BLUE=$'\e[1;44m'
  LIGHT_GREEN=$'\e[1;32m';   BG_LIGHT_GREEN=$'\e[1;42m'
   LIGHT_CYAN=$'\e[1;36m';    BG_LIGHT_CYAN=$'\e[1;46m'
    LIGHT_RED=$'\e[1;31m';     BG_LIGHT_RED=$'\e[1;41m'
 LIGHT_PURPLE=$'\e[1;35m';  BG_LIGHT_PURPLE=$'\e[1;45m'
       YELLOW=$'\e[1;33m';        BG_YELLOW=$'\e[1;43m'
         GRAY=$'\e[0;37m';          BG_GRAY=$'\e[0;47m'
        WHITE=$'\e[1;37m';         BG_WHITE=$'\e[1;47m'
         BOLD=$'\e[1;39m'

carg1="$GRAY$BG_BLUE"
carg2="$CYAN$BG_BROWN"
cesc1="$BOLD$BG_WHITE$RED"

cstart=''
cend=''
cesc=''

count_newline () {
    nl="${hoge//[^$newline]/}"
    echo ${#nl}
}

output () {
    local opt_strict=no
    case $1 in
        # don't print if it doesn't fit the original offset range
        --strict) opt_strict=yes; shift;;
    esac
    local str="$1"
    local start=${2:-0}
    local end=${3:-${#str}}
    local newlines nr_newlines output
    local fragment # a string that supposed to be output, but before escape.
    fragment="${str:start:end}"
    if [ "$opt_strict" = yes -a ${#fragment} -ne ${#str} ]; then
        # it's too long even before escaping newlines
        return 1
    fi

    # adjust width by number of newlines if we escape them
    # if we only have start, cut the begening.
    # if we have range (start and end), cut the tail.
    newlines="${fragment//[^$newline]/}"
    nr_newlines=${#newlines}
    if [ "$opt_escape" = yes ]; then
        case $# in
            2) ((start = $2 + nr_newlines));;
            3) ((end = $3 - nr_newlines));;
        esac
    fi

    output="${str:start:end}"

    if [ "$opt_strict" = yes -a ${#output} -ne ${#arg} ]; then
        # it's too long even before escaping newlines
        return 1
    fi

    if [ "$opt_escape" = yes ]; then
        output="${output//$newline/$cesc\\n$cstart}"
    fi

    echo -n "$cstart$output$cend"
}

cols=$(tput cols || echo $default_cols) >/dev/null 2>&1
shorten () {
    local offset="$1" # adjust line length with -n option etc.
    local lineno="$2" # alternating color
    local str="$3"
    dots="..."
    (( width = cols - $offset ))
    if (( ${#str} > width && cols > mid_omit_minimum + ${#dots} + tail_keep))
    then
        (( mid_omit_start = width - ${#dots} - tail_keep))
        (( tailstart = ${#str} - tail_keep ))
        output "${str}" 0 $mid_omit_start
        echo -n "${dots}"
        output "${str}" $tailstart
        printf '\n'
    else
        if output --strict "${str}" 0 $width
        then
            printf '\n'
        else
            output "${str}" 0 $(( width - ${#dots} ))
            printf "${dots}\n"
        fi
    fi
}

print_args () {
    i=1
    offset=0
    for arg in "$@"
    do
        if [ "$opt_color" = yes ]; then
            cend=$'\e[0m'
            if (( i % 2 == 0 )); then
                local cstart="$carg1"
            else
                local cstart="$carg2"
            fi
        fi
        if [ "$opt_lineno" = yes ]
        then
            printf '%3d ' $i
            offset=4
        fi
        if [ "$opt_full" = yes ]
        then
            output "${cstart}${arg}${cend}"
            printf '\n'
        else
            shorten $offset $i "$arg"
        fi
        (( i++ ))
    done
}

#############################################################################

[ -t 1 ] && opt_color=yes

while [ $# -gt 0 ]
do
    case $1 in
    -h|--help)   print_help; exit 0;;
    -p|--pid)    opt_pid=yes;;
    -f|--full)   opt_full=yes;   recursive_opts+=('$1');;
    -n|--number) opt_lineno=yes; recursive_opts+=('$1');;
    -m|--mono)   opt_color=no;   recursive_opts+=('$1');;
    -c|--color)  opt_color=yes;  recursive_opts+=('$1');;
    -e|--escape) opt_escape=yes; recursive_opts+=('$1');;
    --) shift; break;;
    *) break;;
    esac
    shift
done

[ $# -eq 1 ] && [[ $1 =~ [0-9]+ ]] && opt_pid=yes
if [ "$opt_pid" = yes -a $# -ne 1 ]
then
    DIE "-p/--pid option takes only one argument"
fi

# Need this to prevent expansion error caused by set -u
recursive_opts+=('--')

if [ "$opt_color" = yes ]; then
    cesc="$cesc1"
fi

if [ "$opt_pid" = yes ]
then
    cmdline="/proc/$1/cmdline"
    if [ -r $cmdline ]
    then
        cat "$cmdline" | xargs -0 "$0" ${recursive_opts[@]}
    else
        DIE "Cannot read $cmdline. Invalid PID or process exited?"
    fi
else
    print_args "$@"
fi
